保存文件的格式变了，图的输入输出比较麻烦，采用文件读取方式

## 树和图的搜索

- 深度优先搜索 DFS 空间 O(h) 不具有最短性
  - 注意 回溯 和 剪枝
    - 回溯 要 回复现场，在递归进入下一层，调用完成后
    - 剪枝 提前判断继续递归下去是 不合法的/不是最优，结束调用
- 宽度优先搜索 BFS 空间 O(2^h) "最短路"
  - 第一次搜索全部路径为 1 的点，第二搜索全部路径为 2 的点，依次下去
  - 基本框架
    ```js
    queue <- 初始
     while (queue 不空) {
         t <- 队头
         拓展 t
     }
    ```

## 树和图的遍历

- 树与图的存储
  - 树是无环连通图，可以看作一种特殊的图
  - 图分为 有向图 和 无向图，无向图可以看作有向图
  - 有向图
    - 邻接矩阵，一个二维矩阵
    - 邻接表，一个保存顶点的数组，每个顶点连接其他点组成的链表
- 树与图的深度优先遍历
- 树与图的宽度优先遍历
- 拓扑排序
  - 针对有向图的，无向图没有
  - 找到所有入度为 0 的点，删除，最后没有则存在拓扑序列

## 最短路

(n 为点数，m 为边数)

- 单源最短路
  - 所有边权都是正数
    - **朴素 Dijkstra 算法** O(n^2) 适合 边多的 稠密图
    - **堆优化版的 Dijkstra 算法** O(mlog n)
  - 存在负权边
    - **Bellman-Ford** O(nm)
    - **SPFA** 一般:O(m)，最坏:O(nm)
- 多源汇最短路
  - **Floyd 算法** O(n^3)

### 难点

建图，把内容抽象成一个图的问题，找到最短路

### 朴素 Dijkstra 算法

基于 贪心的思想
基于 稠密图 ，用 邻接矩阵
时间复杂度 O(n^2)

```cpp
dist[1]=0,dist[i]= INF; // +∞
for(auto i : dist){
  t <- 不在st中的，距离源点最近的点; // O(n)
  s <- t; //O(n)
  用 t 更新其他结点的距离; //O(m)
}
```

找到距离最近的点，用最短距离的点更新其他距离的点，能保证他是最短距离的点

### 堆优化版 Dijkstra 算法

适用于 稀疏图，用 邻接表 保存
时间复杂度 O(mlogn)

```cpp
dist[1]=0,dist[i]= INF; // +∞
for(auto i : dist){
  t <- 不在st中的，距离源点最近的点; //这里优化为 O(1)
  s <- t; //O(n)
  用 t 更新其他结点的距离; //但是会增加 O(m log n)
}
```

#### 堆的实现

- 手写堆 ，可以读取任意的数
- 优先队列，(会有点像宽搜)

### Bellman_Ford 算法

负权回路，不一定存在最短路径(负权回路不能到达 n 点)
也可以用来找**负权回路**

边的存储方式简单，`a,b,w`数组即可
时间复杂度 O(n\*m)

```cpp
for n 次 // 有实际意义的，第 n+1 次还更新，说明存在负权回路
  for 所有边 a,b,w  a -w-> b
    dist[b]= min(dist[b],dist[b]+w)//松弛操作
```

执行结束一定满足 `dist[b]<=dist[a]+w`
称，**三角不等式**

### SPFA 算法 用宽搜对 Bellman_Ford 算法做优化

用宽搜对 Bellman_Ford 算法做优化

核心思想：一个发生更新，才会引发后继的更新，所以用一个队列保存发生更新的点

在部分情况下，比 堆优化的 Dijkstra 还要好。推荐用这种方式

```cpp
queue <- 1
while (queue 不空){
  // 1
  t <- q.fornt;
  q.pop();

  // 2
  更新t的所有出边 t -w-> b;
  queue <- b;
}
```

### SPFA 判断是否存在负权回路

```cpp
dist[x]; // 从源点出发的距离
cnt[x];  // 经过的边数

dist[x] = dist[t]+ w[i];
cnt[x]= cnt[t] + 1;

if(cnt[x]>= n){
  // 存在负权回路
}
```

### Floyd 算法

基于动态规划

状态转移，参数：经过的边的集合，出发点，目的点
`d[k,i,j] = d[k-1,i,k]+ d[k-1,k,j]`

从 i 到 j 经过 k 点，遍历一遍即可，不关心第一个参数，省略后，即答案

```cpp
for (int k = 1; k <= n; k++)
  for (int i = 1; i <= n; i++)
    for (int j = 1; j <= n; j++)
      d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
```

## 最小生成树和二分图

只适用于图

- 最小生成树
  - 普利姆算法 (Prim)
    - 朴素版 Prim 适用于绸密图 O(n^2)
    - 堆优化版 Prim 适用于稀疏图 O(mlogn) 一般用下面下那个
  - 克鲁斯卡尔算法 (Kruskal) 适用于稀疏图 O(mlogm)
- 二分图
  - 染色法 O(n+m)
  - 匈牙利算法 O(mn), 实际运行时间一般远小于

### 朴素 Prim 算法

每次找到相邻的最小边

跟 Dijkstra 算法比较像

```cpp
dist[i] <- +∞;
for(int i=0;i<n;i++)
  t <- 找到集合外距离最近的点;
  用 t 更新其他点到 **集合** 的距离;
  st[t]= true;
```

### Kruskal 算法

1. 将所有边按权重从小到大排序 O(mlogm)
2. 枚举每条边 `a,b` 权重 `c` 。 if a,b 不连通，将这条边加入集合中。也用到了 **并查集** 的应用 O(m)

## 二分图

区别二分图，关键是看点集是否能分成两个独立的点集。

充分必要条件：**二分图当且仅当图中不含 奇数环**（一个环的边数为奇数）

### 染色法判断是不是二分图

其实也是 **顶点染色问题** ，一条边上的两个顶点不属于同一个集合，1 相邻的点为 2，2 相邻的点为 1。

由于图中不含奇数环，所以染色过程中一定没有矛盾

```cpp
for(i=1;i<=n,i++)
  if i 未染色
    dfs(i,1) //
```

### 匈牙利算法

基本思路：最大匹配两个集合内的一对一的边
（数学表述：在二分图中最多能找到多少条没有公共端点的边）

假设集合 A 为男生，集合 B 为女生

最大匹配是 找到一个男生匹配一个女生的个数，一个男生 A 匹配女生 A，发现女生 A 已经有男生 B 了，可以尝试这个女生 A 匹配的男生 B 有没有下家，如果有，则男生 B 匹配女生 B，男生 A 匹配女生 A，如果过递归能进行下去就算匹配成功；如果不行，男生 A 去匹配下一个女生 C

其实流程跟我们上面描述的是一致的。注意这里使用了一个递归的技巧，我们不断往下递归，尝试寻找合适的匹配。
