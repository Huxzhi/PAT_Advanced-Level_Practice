# 动态规划 DP

1.  常用模型
    1. 状态表示
    2. 状态计算
2.  不同类型的 DP
    1. 背包问题
    2. 线性 DP
    3. 区间 DP
    4. 计数类 DP
    5. 数位统计 DP
    6. 状态压缩 DP
    7. 树形 DP
    8. 记忆化搜索

## 优点

DP 是枚举**有希望成为答案的解**。这个空间比暴力的小得多，自动**剪枝**

动态规划，无非就是利用**历史记录**，来避免我们的重复计算。而这些**历史记录**，我们得需要一些**变量**来保存，一般是用**一维数组**或者**二维数组**来保存。

### 满足的优化的条件

1. **无后效性**
   1. 满足该状态后，只需记住其中一个属性即可，后续的状态转移和该状态无关
   2. （严格定义：如果给定某一阶段的状态，则在这一阶段以后过程的发展不受这阶段以前各段状态的影响。）
2. **最优子结构**
   1. 大问题的**最优解**可以由小问题的**最优解**推出，这个性质叫做“最优子结构性质”。

## 背包问题

$N$ 个物品，容量是 $V$ 的背包

每个物品有 $v_i$ 体积,$w_i$ 价格 两个属性

- Dp
  - 状态表示 $f(i,j)$,i 表示 选法，j 表示背包容量 `f[i][j]` 表示属性的值
    - 集合（选法的集合）,条件
      - 只从前 $j$ 的物品中选
      - 总体积 $\le j$
    - 属性（**Max**，Min，数量）
  - 状态计算
    - 集合的划分，分成两个状态，原则：不重不漏
      - 计算从 不含 $i$ 的状态 到 含 $i$ 的状态

### 优化助记

从上一层状态的话，是从大到小，可以保证都没有用过
从本层的状态的话，是从小到大，正向枚举

### 01 背包问题

**每件物品最多使用一次**，在不超过体积的情况下，获得最多的价格

- 状态计算
  - 集合的划分，分成两个状态，原则：不重不漏
    - 计算从 不含 $i$ 的状态 到 含 $i$ 的状态
      - $f(i,j)= Max( f(i-1,j) , f(i,j-V_i)+w_i)$
      - 含 $i$ 不好求，曲线救国一下，不影响结果
- 优化
  - 一般是对公式做等价代换 或 公式变形
  - 如上述例子，$f(i,j),f(i-1,j)$ ，只与上一行数组有关，可以将二维数组，优化为 滚动数组（一维数组），从后往前覆盖即可

动态规划的核心思想避免重复计算在 01 背包问题中体现得淋漓尽致。第 i 件物品装入或者不装入而获得的最大价值完全可以由前面 i-1 件物品的最大价值决定，**暴力枚举**忽略了这个事实。

### 完全背包问题

**每件物品有无限个**

状态计算 **集合的划分** 不一样
$f[i,j] =\max f[i-1,j-v[i]*k] + w[i]*k$

#### 优化状态转移方程

```cpp
f[i,j] = max(f[i-1,j],f[i-1,j-v]+w,f[i-1,j-2v]+2w,...,f[i-1,j-sv]+sw)
f[i,j-v] = max(      ,f[i-1,j-v], f[i-1,j-2v]+w,..., f[i-1,j-sv]+(s-1)w, f[i-1,j-(s+1)v]+sw)
```

### 多重背包问题

**每件物品的个数不一样**

和朴素版本的完全背包问题一样

`f[i][j] = max(f[i - 1][j - v[i] * k] + w[i] * k); k = 0, 1, 2, ..., s[i]`

### 优化 多重背包问题 Ⅱ 二进制优化

但是 max 不能求出前 n-1 个最大值，所以，多重背包问题没办法用完全背包问题的思路优化。

这里引出一种新的思路： 将一个多重背包问题化为 01 背包问题， 即如果一个物品有 s 个，那么实际上我们可以将其拆为 s 份，每一份为一个新的物品，物品的重量与价值保持不变，对于每件物品只有装入和不装入两种选择，这样再重新组织后，一个多重背包问题就被转化为 01 背包问题。

然而直接拆分成 s 份的复杂度实际上是很高的：即 S x N。

下一步就引出了我们要使用的方法，用二进制的方法来拆分物品。

$1,2,4,\dots,2^k , (s-2^k) \equiv 0 \dots s$ ;  
k 的范围 $2^k <s\le 2^{k+1}$

将多重背包问题转化为 01 背包问题所以用 01 背包问题的解法即可。
时间复杂度为 O(N x V log S)

### 分组背包问题

**每组只能选择一个**

在 01 背包 的基础上
状态表示按组进行分类，需要三重循环

```cpp
for (int i = 1; i <= n; i++)
    for (int j = m; j >= 0; j--)
        for (int k = 0; k < s[i]; k++)
            if (v[i][k] <= j)
                f[j] = max(f[j], f[j - v[i][k]] + w[i][k]);
```

## 线性 DP

## 区间 DP

## 计数类 DP

## 数位统计 DP

## 状态压缩 DP

## 树形 DP

## 记忆化搜索
