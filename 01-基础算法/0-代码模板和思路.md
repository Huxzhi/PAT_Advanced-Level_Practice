---
date: 2024-03-01 16:00
updated: 2024-03-07 10:58
---

# 基础算法

- [排序](#排序)
- [二分](#二分)
- [高精度](#高精度)
- [前缀和-差分](#前缀和-差分)
- [双指针算法](#双指针算法)
- [位运算](#位运算)
- [离散化](#离散化)
- [区间合并](#区间合并)

## 排序

### 快速排序——分治

1. 确定分界点
2. 分隔区间，处理左右区间
3. 递归已处理区间内部的左右分隔

虽然考试一般用 `sort()` 不会写了，思想还是记一下

```cpp
// l = 0 , r = N - 1
quick_sort(int q[],int l,int r){
if(l >= r)
    return ;
int x= q[l]

int i=l,j=r;
while(l<r){
    while (q[i] < x ) i++;
    while (q[j] >) j--;
    if(i<j) swap(q[i],q[j])
}

quick_sort(q,l,i);
quick_sort(q,j,r);

}
```

### 归并排序——分治

1. 确定分界点
2. 递归划分区间
3. 处理合并

```cpp
int tmp[N] // 和q数组一样大小

void merge_sort(int q[], l, r){

if (l>=r) return ;

int mid = (l + r ) / 2;


merge_sort(q,l,mid);
merge_sort(q,mid+1,r);

// 处理合并
int k=0, i=l ,j=mid+1
while(i<=mid && j <= r)
    if(q[l]<q[mid+1]){
        tmp[k++] = q[i++]
    }else{
        tmp[k++] = q[i++]
    }

while(l <= mid) tmp[k++] = q[l++];
while(j <= r) tmp[k++] = q[l++];

// 放回原处
for(i=l,j=0;i<=r;i++,j++)
    q[i] = tmp[j]

}
```

## 二分

### 整数二分

1. 确定分界点
2. 对检测下一步去哪个区间
3. 更新区间
4. 注意点：判断边界，如果是 `l = mid` 一开始就要 `mid= l + r + 1 >> 1 ` 不然会陷入死循环

### 浮点数二分

不需要判断边界，只需要设置 结束条件，比如左右区间小于某个值即可，经典应用求平方根

精度要求比 结果的精度+2

## 高精度

就是把 `long long` 大整数 改成用字符串保存

### 高精度加法

加法，模仿机组的寄存器

保留一个进位

```cpp
C.push_back(t % 10);
t /= 10;
```

### 高精度减法

同理

### 高精度乘法

大数 x 小数

具体是 for 循环 大数的一位 x 小数

### 高精度除法

```cpp
// r 余数 A[i] 大数，b小数
r = 0;
for (int i = A.size() - 1; i >= 0; i--)
{
    r = r * 10 + A[i];

    C.push_back(r / b);
    r %= b;
}
// 这里数据要反一下，然后去掉前导零
reverse(C.begin(), C.end());
```

## 前缀和-差分

两者为逆运算

### 前缀和

公式简单，相当于预处理。求区间内的元素之和的复杂度为 $O(1)$

- $S_i = a_0+ a_1 + a_2 + \dots + a_i$
- $a_i=S_i -S_{i-1}$

### 子矩阵求和

重点是 子矩阵求和， 类似 二维概率函数 求 二维分布函数

- 初始化 `s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + a[i][j];`
- 子矩阵`(x1,y1) ,(x2,y2)`求和为 `s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1];`

### 差分

已知 `a[i]` ，构造一个 `b[i]` 数组，满足 $a_i = b_0+ b_1 + b_2 + \dots + b_i$ 。`b[i]` 数组通过前缀和 得到 `a[i]` 数组

应用场景
多次对 某个区间+c ，的复杂度为$O(1)$

### 差分矩阵

初始化

```cpp
void insert(int x1, int y1, int x2, int y2, int c)
{
    b[x1][y1] += c;
    b[x2 + 1][y1] -= c;
    b[x1][y2 + 1] -= c;
    b[x2 + 1][y2 + 1] += c;
}

for (int i = 1; i <= n; i++)
    for (int j = 1; j <= m; j++)
        insert(i, j, i, j, a[i][j]); // 初始化
```

输出结果

```cpp
for (int i = 1; i <= n; i++)
    for (int j = 1; j <= n; j++)
        b[i][j] += b[i - 1][j] + b[i][j - 1] - b[i - 1][j - 1];
```

## 双指针算法

是这种思想

将暴力的 双重 for 循环，复杂为$O(n^2)$ ，找到两者之间的关系，优化为 $O(n)$

### 最长连续不重复子序列

空间换时间

### 数组去重

先排序，若 第 i 个 和 第 i-1 个 相同，则重复，

```cpp
for (int i = 0; i < a.size(); i++)
{
    if (!i || a[i] != a[i - 1])
        a[j++] = a[i];
}
```

## 位运算

这里需要回到 变量在计算机的保存方式，补码

### lowbit(x)

返回最右边的一位 1，

内部实现 `x&-x` 即 `x&(~x+1)`

求 x 的二进制有多少位 1

```cpp
int x,m=0;
while(x){
    x-=x&(~x+1);
    m++;
}
```

### 整数快速求 二进制的表达式

```cpp
int n = 10;
// 逆序输出
for (int k = 3; k >= 0; k--)
{
    cout << (n >> k & 1);
}
```

## 离散化

用于 个数较少 $10^5$ ，可能的取值范围比较大 $10^9$

### 二分求 x 对应的离散化的值

先排序,需要有序队列

```cpp
int a[N]; // 根据下标查找对应的值
// 二分求出x对应的离散化的值
int find(int x) // 找到第一个大于等于x的位置
{

    int l = 0, r = alls.size() - 1;
    while (l < r)
    {
        int mid = l + r >> 1;
        if (alls[mid] >= x)
            r = mid;
        else
            l = mid + 1;
    }

    return r + 1; // 映射到 1,2...n， 与题目有关
}
```

## 区间合并

对区间开始的点排序，从小到大排序，再对三种结果分类讨论

- 下一个区间的的开始和结束都小于当前区间的结束，属于包含关系，不发生改变
- 下一个区间的的开始小于当前区间的结束，结束时间大于小于当前区间的结束，属于交叉关系，当前区间的结束时间为下一个区间的结束时间
- 下一个区间的的开始大于当前区间的结束，不连续，保存当前区间，开始下一个区间
