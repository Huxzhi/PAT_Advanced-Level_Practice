# 04-数学知识

一些简单的数学知识

## 质数

1. 质数在大于 1 的整数中,如果只包含 1 和本身这两个约数,就被成为质数，或者叫素数。

根据唯一分解定理可知，每个大于 1 的数一定可以以唯一的方式被分解为若干个素数的乘

### 质数的判定——试除法

一定是 O(sqrt(n))

```cpp
// 不推荐 i <= sqrt(n) slow
// 也不推荐 i * i <= n 溢出风险
for (int i = 2; i <= n / i; i++)
    if (n % i == 0)
        return false;
```

### 分解质因数——试除法

时间复杂度 O(log n ) 和 O(sqrt(n)) 之间

优化：n 中最多只包含一个大于 sqrt(n)的质因子。循环前 sqrt(n) ，如果有大于 1，则输出剩下的部分

### 筛质数

合数一定是会被质数整除

#### 埃氏筛法

思想：每次筛掉 2 到 n 数 的倍数

优化：每次筛掉 2 到 n 之间质数 的倍数

时间复杂度分析：
n(1+ 1/2 + ... +1/n) 调和级数，为 n ln(n) + c

1-n 中 有 n/(ln n) 个质数

时间复杂度为 O(nlog(logn)) 近似看作 O(n)

#### 线性筛法

核心思想，n 只会被自己最小的质因子筛掉。只会被筛一次，所以叫线性筛法

```cpp
for (int i = 2; i <= n; i++)
{
    if (!st[i])
        primes[cnt++] = i; // 添加到质数表中

    // n 只会被自己最小的质因子筛掉
    for (int j = 0; primes[j] <= n / i; j++)
    {
        st[primes[j] * i] = true;

        if (i % primes[j] == 0) // primes[j] 一定是 i 的最小质因子
            break;
    }
}
```

如何保证 pj 一定是 i 的最小质因子

1. i % pj == 0
   - pj 一定是 i 的最小质因子， pj 一定是 pj\*i 的最小质因子
2. i % pj != 0
   - pj 一定小于 i 的所有质因子,pj 也一定是 pj\*i 的最小质因

在 10^7 量级，大约比埃氏快一倍，10^6 量级差不多

## 约数

什么是约数：如果一个整数能被两个整数整除，那么这两个数是这个数的约数。

### 试除法求一个数的所有约数

同上

### 约数个数

一个数的约数的个数 = 这个数的所有质因子的次数 +1 的乘积。

$N=p_1^{a_1}p_2^{a_2} \dots p_k^{a_k}$

$p_1^{a_1}$的约数有 $p_1^{0},p_1^{2}\cdots p_1^{a_1}$，一共 $a_1+1$ 个，同理 $p_k^{a_k}$ 的个数为 $a_k +1$ 个

所以，**N 的约数个数为 $(a_1+1)(a_2+1)\dots (a_k+1)$**

### 约数之和

从约数个数可知，一共有$(a_1+1)(a_2+1)\dots (a_k+1)$ 种挑法

再根据乘法分配率可知，约数之和为：

$\sigma(n)=(p_{1}^{0}+p_{1}^{1}+p_{1}^{2}+\cdots p_{1}^{a_{1}})(p_{2}^{0}+p_{2}^{1}+p_{2}^{2}+\cdots p_{2}^{a_{2}})\cdots(p_{k}^{0}+p_{k}^{1}+p_{k}^{2}+\cdots p_{k}^{a_{k}})$

多项式展开，就是所有约数

### 最大公约数——欧几里得算法（辗转相除法）

a 和 b 的最大公约数是两数共有的质因数的乘积

公式 $(a,b)=(b,a mod b)$
原理： a 和 b 的 公约数 = b 和 a 取模 b 的公约数

```cpp
// 一行代码
int gcd(int a, int b)
{
    return b ? gcd(b, a % b) : a;
}
```

`b = 0` 的时候结束，此时 `a % 0 = a`

## 欧拉函数

对正整数 n，欧拉函数 φ(n) 是小于或等于 n 的正整数中与 n 互质的数的数目。

$\phi(6) =2$ 6 与 1 和 5 互质

有一个基本的公式

$N=p_1^{a_1}p_2^{a_2}\cdots p_k^{a_k}$ 求出质因子

$\phi(N)=N(1-\frac{1}{p_1})(1-\frac{1}{p_2}) \cdots (1-\frac{1}{p_k})$ ，与质因子的种类有关，与次数无关

### 证明： 容斥原理

1~N 中 和 N 互质的数的个数

1. 从 1~N 中 去掉$p_1,p_2 \cdots p_k$ 的所有倍数
2. 加上所有 $p_i * p_j$ 的倍数（枚举），前面多减了一次
3. 减去所有 $p_i * p_j * p_k$ 的倍数（枚举），前面多加了一次
4. 同理。。。公式展示如下（概率论中的容斥原理）

$$
\begin{equation}
	\begin{split}
     N & -\frac{N}{p_1}-\frac{N}{p_2}- \cdots -\frac{N}{p_k} \\
& + \frac{N}{p_1p_2}+  \frac{N}{p_1p_2}+ \cdots \\
& - \frac{N}{p_1p_2p_3}-  \frac{N}{p_1p_2p_4}-  \cdots \\
& + \frac{N}{p_1p_2p_3p_4}
     \end{split}
\end{equation}
$$

**拓展：**
已知 $p_j$ 为 $i*p_j$ 的最小质因子

若 $i \bmod p_i = 0$

推导： $\phi(i *p_j) = \phi(i) * p_j$

否则： $\phi(i *p_j) = \phi(i) * (p_j -1)$

### 应用：求欧拉定理

若 a 与 n 互质， $a^{\phi(n)} \equiv 1\ (\bmod n)$

欧拉定理说， $a^{\phi(n)}$ 和 1 除于 n 的余数相等。
绕了一大圈，其实就是说 $a^{\phi(n)}$ 除于 n 的余数是 1。

当 n 为质数时，$a^{p-1} \equiv 1\ (\bmod p)$ ，被称为 **费马小定理**

## 快速幂

$a^k \bmod p$ 时间复杂度降低到 O(log k)

### 核心思想

$(a * b) \% p = ((a \% p) * (b \% p)) \% p$ ，我们仔细研究一下这个运算法则，会发现多个因子连续的乘积取模的结果等于每个因子取模后的乘积再取模的结果

### 反复平方法

对 平方进行预处理
$a^{2^0} \bmod p$
$a^{2^1} \bmod p$
$a^{2^2} \bmod p$
$a^{2^ {\log_2 k} } \bmod p$

$a^k \bmod p$ 拆成若干个由上述几个公式相加。相当于 **位移加法运算**

### 快速幂 求 取模运算的 乘法逆元

如果一个线性同余方程 $a x \equiv 1 (\bmod \ b)$，则 $x$ 称为 $a \bmod b$ 的逆元，记作 $a^{-1}$。

#### 乘法逆元的定义

> 若整数 $b,m$ 互质，并且 $b|a$(b 能整除 a)，则存在一个整数 $x$，使得$a/b \equiv a * x(\bmod \ m)$，则称 x 为 b 的模 m 乘法逆元，记为 $b^{-1}(\bmod \  m)$。
>
> $b$ 存在乘法逆元的充要条件是 $b$ 与模数 $m$ 互质。利用前面刚学的费马定理（$b^{m-1} \equiv 1 (\bmod \ m)$），把 b 提出来一个，即 $b * b^{m-2} \equiv 1 (\bmod \ m)$
> 当模数 $m$ 为质数时, $b^{m-2}$ 即为 b 的乘法逆元。

注意， b 不能是 m 的倍数，不然结果不正确

## 扩展欧几里得算法

### 裴蜀定理

对于任意正整数 a,b 一定存在 非零整数 x,y ，使得 $a x + b y = (a, b)$

$d$ 是最大公约数,求 $x,y$

$by+(a-  \lfloor\frac{a}{b}\rfloor  \cdot b)x =d$
$ ax+b(y- \lfloor \frac{a}{b} \rfloor x)=d$

通解为: $\left\{\begin{matrix}   x=x_0 + \frac{b}{d}  k \\ y=y_0 + \frac{a}{d}  k \end{matrix}\right.$

## 中国剩余定理

之后补充
