# 04-数学知识

一些简单的数学知识

## 质数

1. 质数在大于 1 的整数中,如果只包含 1 和本身这两个约数,就被成为质数，或者叫素数。

根据唯一分解定理可知，每个大于 1 的数一定可以以唯一的方式被分解为若干个素数的乘

### 质数的判定——试除法

一定是 O(sqrt(n))

```cpp
// 不推荐 i <= sqrt(n) slow
// 也不推荐 i * i <= n 溢出风险
for (int i = 2; i <= n / i; i++)
    if (n % i == 0)
        return false;
```

### 分解质因数——试除法

时间复杂度 O(log n ) 和 O(sqrt(n)) 之间

优化：n 中最多只包含一个大于 sqrt(n)的质因子。循环前 sqrt(n) ，如果有大于 1，则输出剩下的部分

### 筛质数

合数一定是会被质数整除

#### 埃氏筛法

思想：每次筛掉 2 到 n 数 的倍数

优化：每次筛掉 2 到 n 之间质数 的倍数

时间复杂度分析：
n(1+ 1/2 + ... +1/n) 调和级数，为 n ln(n) + c

1-n 中 有 n/(ln n) 个质数

时间复杂度为 O(nlog(logn)) 近似看作 O(n)

#### 线性筛法

核心思想，n 只会被自己最小的质因子筛掉。只会被筛一次，所以叫线性筛法

```cpp
for (int i = 2; i <= n; i++)
{
    if (!st[i])
        primes[cnt++] = i; // 添加到质数表中

    // n 只会被自己最小的质因子筛掉
    for (int j = 0; primes[j] <= n / i; j++)
    {
        st[primes[j] * i] = true;

        if (i % primes[j] == 0) // primes[j] 一定是 i 的最小质因子
            break;
    }
}
```

如何保证 pj 一定是 i 的最小质因子

1. i % pj == 0
   - pj 一定是 i 的最小质因子， pj 一定是 pj\*i 的最小质因子
2. i % pj != 0
   - pj 一定小于 i 的所有质因子,pj 也一定是 pj\*i 的最小质因

在 10^7 量级，大约比埃氏快一倍，10^6 量级差不多

## 约数

什么是约数：如果一个整数能被两个整数整除，那么这两个数是这个数的约数。

### 试除法求一个数的所有约数

同上

### 约数个数

一个数的约数的个数 = 这个数的所有质因子的次数 +1 的乘积。

$N=p_1^{a_1}p_2^{a_2} \dots p_k^{a_k}$

$p_1^{a_1}$的约数有 $p_1^{0},p_1^{2}\cdots p_1^{a_1}$，一共 $a_1+1$ 个，同理 $p_k^{a_k}$ 的个数为 $a_k +1$ 个

所以，**N 的约数个数为 $(a_1+1)(a_2+1)\dots (a_k+1)$**

### 约数之和

从约数个数可知，一共有$(a_1+1)(a_2+1)\dots (a_k+1)$ 种挑法

再根据乘法分配率可知，约数之和为：

$\sigma(n)=(p_{1}^{0}+p_{1}^{1}+p_{1}^{2}+\cdots p_{1}^{a_{1}})(p_{2}^{0}+p_{2}^{1}+p_{2}^{2}+\cdots p_{2}^{a_{2}})\cdots(p_{k}^{0}+p_{k}^{1}+p_{k}^{2}+\cdots p_{k}^{a_{k}})$

多项式展开，就是所有约数

### 最大公约数——欧几里得算法（辗转相除法）

a 和 b 的最大公约数是两数共有的质因数的乘积

公式 $(a,b)=(b,a mod b)$
原理： a 和 b 的 公约数 = b 和 a 取模 b 的公约数

```cpp
// 一行代码
int gcd(int a, int b)
{
    return b ? gcd(b, a % b) : a;
}
```

`b = 0` 的时候结束，此时 `a % 0 = a`

## 欧拉函数

## 快速幂

## 扩展欧几里得算法

## 中国剩余定理
